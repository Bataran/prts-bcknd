export declare const jugglerModule: any;
import { DataObject, Options } from './common-types';
import { Entity } from './model';
import { Filter, Where } from './query';
import { EntityCrudRepository } from './repository';
export * from './loopback-datasource-juggler';
import { juggler } from './loopback-datasource-juggler';
declare type DataSourceType = juggler.DataSource;
export { DataSourceType };
export declare const DataSourceConstructor: typeof juggler.DataSource;
export declare const ModelBaseConstructor: typeof juggler.ModelBase;
/**
 * This is a bridge to the legacy DAO class. The function mixes DAO methods
 * into a model class and attach it to a given data source
 * @param modelClass {} Model class
 * @param ds {DataSource} Data source
 * @returns {} The new model class with DAO (CRUD) operations
 */
export declare function bindModel<T extends typeof juggler.ModelBase>(modelClass: T, ds: juggler.DataSource): T;
/**
 * Default implementation of CRUD repository using legacy juggler model
 * and data source
 */
export declare class DefaultCrudRepository<T extends Entity, ID> implements EntityCrudRepository<T, ID> {
    entityClass: typeof Entity & {
        prototype: T;
    };
    modelClass: typeof juggler.PersistedModel;
    /**
     * Constructor of DefaultCrudRepository
     * @param modelClass Legacy model class
     * @param dataSource Legacy data source
     */
    constructor(entityClass: typeof Entity & {
        prototype: T;
    }, dataSource: juggler.DataSource);
    create(entity: Partial<T>, options?: Options): Promise<T>;
    createAll(entities: Partial<T>[], options?: Options): Promise<T[]>;
    save(entity: T, options?: Options): Promise<T | null>;
    find(filter?: Filter, options?: Options): Promise<T[]>;
    findById(id: ID, filter?: Filter, options?: Options): Promise<T>;
    update(entity: T, options?: Options): Promise<boolean>;
    delete(entity: T, options?: Options): Promise<boolean>;
    updateAll(data: Partial<T>, where?: Where, options?: Options): Promise<number>;
    updateById(id: ID, data: Partial<T>, options?: Options): Promise<boolean>;
    replaceById(id: ID, data: Partial<T>, options?: Options): Promise<boolean>;
    deleteAll(where?: Where, options?: Options): Promise<number>;
    deleteById(id: ID, options?: Options): Promise<boolean>;
    count(where?: Where, options?: Options): Promise<number>;
    exists(id: ID, options?: Options): Promise<boolean>;
    protected toEntity(model: DataObject<T>): T;
    protected toEntities(models: DataObject<T>[]): T[];
}
