/**
 * An object mapping keys to corresponding metadata
 */
export interface MetadataMap<T> {
    [propertyOrMethodName: string]: T;
}
/**
 * Decorator function types
 */
export declare type DecoratorType = ClassDecorator | PropertyDecorator | MethodDecorator | ParameterDecorator;
/**
 * Base factory class for decorator functions
 *
 * @example
 * ```
 * function classDecorator(spec: MySpec): ClassDecorator {
 *   return ClassDecoratorFactory.createDecorator('my-key', spec);
 * }
 * ```
 * or
 * ```
 * function classDecorator(spec: MySpec): ClassDecorator {
 *   const factory: ClassDecoratorFactory<MySpec>('my-key', spec);
 *   return factory.create();
 * }
 * ```
 * These functions above declare `@classDecorator` that can be used as follows:
 * ```
 * @classDecorator({x: 1})
 * class MyController {}
 * ```
 */
export declare class DecoratorFactory<T, M extends T | MetadataMap<T> | MetadataMap<T[]>, D extends DecoratorType> {
    protected key: string;
    protected spec: T;
    protected allowInheritance: boolean;
    /**
     * A symbol to reference the target of a decoration
     */
    static TARGET: symbol;
    /**
     * Construct a new class decorator factory
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    constructor(key: string, spec: T, allowInheritance?: boolean);
    /**
     * Inherit metadata from base classes. By default, this method merges base
     * metadata into the spec if `allowInheritance` is set to `true`. To customize
     * the behavior, this method can be overridden by sub classes.
     *
     * @param baseMeta Metadata from base classes for the member
     */
    protected inherit(baseMeta: T | undefined | null): T;
    /**
     * Get name of a decoration target
     * @param target Class or prototype of a class
     * @param member Optional property/method name
     * @param descritorOrIndex Optional property/method descriptor or parameter index
     */
    getTargetName(target: Object, member?: string | symbol, descriptorOrIndex?: TypedPropertyDescriptor<any> | number): string;
    /**
     * Set a reference to target for a given spec if the it's an object
     * @param spec Metadata spec
     * @param target Class or prototype of a class
     */
    withTarget(spec: T, target: Object): T;
    /**
     * Get the optional decoration target of a given spec
     * @param spec Metadata spec
     */
    getTarget(spec: T): any;
    /**
     * To be overridden by subclasses to process inherited metadata
     * @param meta Metadata inherited from the base
     * @param target Decoration target
     * @param member Optional property or method
     * @param descriptorOrIndex Optional parameter index or method descriptor
     */
    protected processInherited(baseMeta: M, target: Object, member?: string | symbol, descriptorOrIndex?: TypedPropertyDescriptor<any> | number): M;
    /**
     * To be overridden by subclasses to process local metadata
     * @param meta Metadata exists on the target
     * @param target Decoration target
     * @param member Optional property or method
     * @param descriptorOrIndex Optional parameter index or method descriptor
     */
    protected processLocal(localMeta: M, target: Object, member?: string | symbol, descriptorOrIndex?: TypedPropertyDescriptor<any> | number): M;
    /**
     * Create a decorator function of the given type. Each sub class MUST
     * implement this method.
     */
    create(): D;
    /**
     * Base implementation of the decorator function
     * @param target Decorator target
     * @param member Optional property or method
     * @param descriptorOrIndex Optional method descriptor or parameter index
     */
    protected decorate(target: Object, member?: string | symbol, descriptorOrIndex?: TypedPropertyDescriptor<any> | number): void;
    /**
     * Create a decorator function
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    protected static _createDecorator<T, M extends T | MetadataMap<T> | MetadataMap<T[]>, D extends DecoratorType>(key: string, spec: T, allowInheritance?: boolean): D;
}
/**
 * Factory for class decorators
 */
export declare class ClassDecoratorFactory<T> extends DecoratorFactory<T, T, ClassDecorator> {
    protected processInherited(baseMeta: T, target: Object, member?: string | symbol, descriptorOrIndex?: TypedPropertyDescriptor<any> | number): T;
    protected processLocal(localMeta: T, target: Object, member?: string | symbol, descriptorOrIndex?: TypedPropertyDescriptor<any> | number): T;
    create(): ClassDecorator;
    /**
     * Create a class decorator function
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    static createDecorator<T>(key: string, spec: T, allowInheritance?: boolean): ClassDecorator;
}
/**
 * Factory for property decorators
 */
export declare class PropertyDecoratorFactory<T> extends DecoratorFactory<T, MetadataMap<T>, PropertyDecorator> {
    protected processInherited(baseMeta: MetadataMap<T>, target: Object, propertyName?: string | symbol, descriptorOrIndex?: TypedPropertyDescriptor<any> | number): MetadataMap<T>;
    protected processLocal(localMeta: MetadataMap<T>, target: Object, propertyName?: string | symbol, descriptorOrParameterIndex?: TypedPropertyDescriptor<any> | number): MetadataMap<T>;
    create(): PropertyDecorator;
    /**
     * Create a property decorator function
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    static createDecorator<T>(key: string, spec: T, allowInheritance?: boolean): PropertyDecorator;
}
/**
 * Factory for method decorators
 */
export declare class MethodDecoratorFactory<T> extends DecoratorFactory<T, MetadataMap<T>, MethodDecorator> {
    protected processInherited(baseMeta: MetadataMap<T>, target: Object, methodName?: string | symbol, methodDescriptor?: TypedPropertyDescriptor<any> | number): MetadataMap<T>;
    protected processLocal(localMeta: MetadataMap<T>, target: Object, methodName?: string | symbol, methodDescriptor?: TypedPropertyDescriptor<any> | number): MetadataMap<T>;
    create(): MethodDecorator;
    /**
     * Create a method decorator function
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    static createDecorator<T>(key: string, spec: T, allowInheritance?: boolean): MethodDecorator;
}
/**
 * Factory for parameter decorators
 */
export declare class ParameterDecoratorFactory<T> extends DecoratorFactory<T, MetadataMap<T[]>, ParameterDecorator> {
    protected processInherited(baseMeta: MetadataMap<T[]>, target: Object, methodName?: string | symbol, parameterIndex?: TypedPropertyDescriptor<any> | number): MetadataMap<T[]>;
    protected processLocal(localMeta: MetadataMap<T[]>, target: Object, methodName?: string | symbol, parameterIndex?: TypedPropertyDescriptor<any> | number): MetadataMap<T[]>;
    create(): ParameterDecorator;
    /**
     * Create a parameter decorator function
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    static createDecorator<T>(key: string, spec: T, allowInheritance?: boolean): ParameterDecorator;
}
