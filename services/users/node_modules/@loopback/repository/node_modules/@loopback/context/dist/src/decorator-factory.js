"use strict";
// Copyright IBM Corp. 2013,2017. All Rights Reserved.
// Node module: @loopback/context
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
Object.defineProperty(exports, "__esModule", { value: true });
const reflect_1 = require("./reflect");
const _ = require("lodash");
const debugModule = require("debug");
const debug = debugModule('loopback:decorator');
// tslint:disable:no-any
function cloneDeep(val) {
    if (val === undefined) {
        return {};
    }
    return _.cloneDeepWith(val, v => {
        // Do not clone functions
        if (typeof v === 'function')
            return v;
        return undefined;
    });
}
/**
 * Base factory class for decorator functions
 *
 * @example
 * ```
 * function classDecorator(spec: MySpec): ClassDecorator {
 *   return ClassDecoratorFactory.createDecorator('my-key', spec);
 * }
 * ```
 * or
 * ```
 * function classDecorator(spec: MySpec): ClassDecorator {
 *   const factory: ClassDecoratorFactory<MySpec>('my-key', spec);
 *   return factory.create();
 * }
 * ```
 * These functions above declare `@classDecorator` that can be used as follows:
 * ```
 * @classDecorator({x: 1})
 * class MyController {}
 * ```
 */
class DecoratorFactory {
    /**
     * Construct a new class decorator factory
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    constructor(key, spec, allowInheritance = true) {
        this.key = key;
        this.spec = spec;
        this.allowInheritance = allowInheritance;
    }
    /**
     * Inherit metadata from base classes. By default, this method merges base
     * metadata into the spec if `allowInheritance` is set to `true`. To customize
     * the behavior, this method can be overridden by sub classes.
     *
     * @param baseMeta Metadata from base classes for the member
     */
    inherit(baseMeta) {
        if (!this.allowInheritance)
            return this.spec;
        if (baseMeta == null)
            return this.spec;
        if (this.spec == undefined)
            return baseMeta;
        if (typeof baseMeta !== 'object')
            return this.spec;
        if (Array.isArray(baseMeta) || Array.isArray(this.spec)) {
            // For arrays, we don't merge
            return this.spec;
        }
        return Object.assign(baseMeta, this.spec);
    }
    /**
     * Get name of a decoration target
     * @param target Class or prototype of a class
     * @param member Optional property/method name
     * @param descritorOrIndex Optional property/method descriptor or parameter index
     */
    getTargetName(target, member, descriptorOrIndex) {
        let name = target instanceof Function
            ? target.name
            : target.constructor.name + '.prototype';
        if (member == null && descriptorOrIndex == null) {
            return 'class ' + name;
        }
        if (member == null)
            member = 'constructor';
        if (typeof descriptorOrIndex === 'number') {
            // Parameter
            name =
                'parameter ' +
                    name +
                    '.' +
                    member.toString() +
                    '[' +
                    descriptorOrIndex +
                    ']';
        }
        else if (descriptorOrIndex != null) {
            name = 'method ' + name + '.' + member.toString();
        }
        else {
            name = 'property ' + name + '.' + member.toString();
        }
        return name;
    }
    /**
     * Set a reference to target for a given spec if the it's an object
     * @param spec Metadata spec
     * @param target Class or prototype of a class
     */
    withTarget(spec, target) {
        if (typeof spec === 'object' && spec != null) {
            const specWithTarget = spec;
            specWithTarget[DecoratorFactory.TARGET] = target;
        }
        return spec;
    }
    /**
     * Get the optional decoration target of a given spec
     * @param spec Metadata spec
     */
    getTarget(spec) {
        if (typeof spec === 'object' && spec != null) {
            const specWithTarget = spec;
            return specWithTarget[DecoratorFactory.TARGET];
        }
    }
    /**
     * To be overridden by subclasses to process inherited metadata
     * @param meta Metadata inherited from the base
     * @param target Decoration target
     * @param member Optional property or method
     * @param descriptorOrIndex Optional parameter index or method descriptor
     */
    processInherited(baseMeta, target, member, descriptorOrIndex) {
        return baseMeta;
    }
    /**
     * To be overridden by subclasses to process local metadata
     * @param meta Metadata exists on the target
     * @param target Decoration target
     * @param member Optional property or method
     * @param descriptorOrIndex Optional parameter index or method descriptor
     */
    processLocal(localMeta, target, member, descriptorOrIndex) {
        return localMeta;
    }
    /**
     * Create a decorator function of the given type. Each sub class MUST
     * implement this method.
     */
    create() {
        throw new Error('create() is not implemented');
    }
    /**
     * Base implementation of the decorator function
     * @param target Decorator target
     * @param member Optional property or method
     * @param descriptorOrIndex Optional method descriptor or parameter index
     */
    decorate(target, member, descriptorOrIndex) {
        const targetName = this.getTargetName(target, member, descriptorOrIndex);
        let meta = reflect_1.Reflector.getOwnMetadata(this.key, target);
        if (meta == null && this.allowInheritance) {
            // Clone the base metadata so that it won't be accidentally
            // mutated by sub classes
            meta = cloneDeep(reflect_1.Reflector.getMetadata(this.key, target));
            meta = this.processInherited(meta, target, member, descriptorOrIndex);
            if (debug.enabled) {
                debug('%s: %j', targetName, meta);
            }
            reflect_1.Reflector.defineMetadata(this.key, meta, target);
        }
        else {
            meta = this.processLocal(meta, target, member, descriptorOrIndex);
            if (debug.enabled) {
                debug('%s: %j', targetName, meta);
            }
            reflect_1.Reflector.defineMetadata(this.key, meta, target);
        }
    }
    /**
     * Create a decorator function
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    static _createDecorator(key, spec, allowInheritance = true) {
        const inst = new this(key, spec, allowInheritance);
        return inst.create();
    }
}
/**
 * A symbol to reference the target of a decoration
 */
DecoratorFactory.TARGET = Symbol('decorationTarget');
exports.DecoratorFactory = DecoratorFactory;
/**
 * Factory for class decorators
 */
class ClassDecoratorFactory extends DecoratorFactory {
    processInherited(baseMeta, target, member, descriptorOrIndex) {
        return this.withTarget(this.inherit(baseMeta), target);
    }
    processLocal(localMeta, target, member, descriptorOrIndex) {
        if (localMeta != null) {
            throw new Error('Decorator cannot be applied more than once on ' +
                this.getTargetName(target));
        }
        return this.withTarget(this.spec, target);
    }
    create() {
        return (target) => this.decorate(target);
    }
    /**
     * Create a class decorator function
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    static createDecorator(key, spec, allowInheritance = true) {
        return super._createDecorator(key, spec, allowInheritance);
    }
}
exports.ClassDecoratorFactory = ClassDecoratorFactory;
/**
 * Factory for property decorators
 */
class PropertyDecoratorFactory extends DecoratorFactory {
    processInherited(baseMeta, target, propertyName, descriptorOrIndex) {
        const propertyMeta = this.withTarget(this.inherit(baseMeta[propertyName]), target);
        baseMeta[propertyName] = propertyMeta;
        return baseMeta;
    }
    processLocal(localMeta, target, propertyName, descriptorOrParameterIndex) {
        if (localMeta == null)
            localMeta = {};
        if (localMeta[propertyName] != null) {
            const targetName = this.getTargetName(target, propertyName);
            throw new Error('Decorator cannot be applied more than once on ' + targetName);
        }
        localMeta[propertyName] = this.withTarget(this.spec, target);
        return localMeta;
    }
    create() {
        return (target, propertyName) => this.decorate(target, propertyName);
    }
    /**
     * Create a property decorator function
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    static createDecorator(key, spec, allowInheritance = true) {
        return super._createDecorator(key, spec, allowInheritance);
    }
}
exports.PropertyDecoratorFactory = PropertyDecoratorFactory;
/**
 * Factory for method decorators
 */
class MethodDecoratorFactory extends DecoratorFactory {
    processInherited(baseMeta, target, methodName, methodDescriptor) {
        const methodMeta = this.withTarget(this.inherit(baseMeta[methodName]), target);
        baseMeta[methodName] = methodMeta;
        return baseMeta;
    }
    processLocal(localMeta, target, methodName, methodDescriptor) {
        if (localMeta == null)
            localMeta = {};
        if (localMeta[methodName] != null) {
            throw new Error('Decorator cannot be applied more than once on ' +
                this.getTargetName(target, methodName, methodDescriptor));
        }
        // Set the method metadata
        localMeta[methodName] = this.withTarget(this.spec, target);
        return localMeta;
    }
    create() {
        return (target, methodName, descriptor) => this.decorate(target, methodName, descriptor);
    }
    /**
     * Create a method decorator function
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    static createDecorator(key, spec, allowInheritance = true) {
        return super._createDecorator(key, spec, allowInheritance);
    }
}
exports.MethodDecoratorFactory = MethodDecoratorFactory;
/**
 * Factory for parameter decorators
 */
class ParameterDecoratorFactory extends DecoratorFactory {
    processInherited(baseMeta, target, methodName, parameterIndex) {
        const method = methodName ? methodName : '';
        let methodMeta = baseMeta[method];
        if (methodMeta == null) {
            // Initialize the method metadata
            methodMeta = [];
            baseMeta[method] = methodMeta;
        }
        const index = parameterIndex;
        methodMeta[index] = this.withTarget(this.inherit(methodMeta[index]), target);
        return baseMeta;
    }
    processLocal(localMeta, target, methodName, parameterIndex) {
        const method = methodName ? methodName : '';
        if (localMeta == null)
            localMeta = {};
        // Find the method metadata
        let methodMeta = localMeta[method];
        if (methodMeta == null) {
            // Initialize the method metadata
            methodMeta = [];
            localMeta[method] = methodMeta;
        }
        const index = parameterIndex;
        if (this.getTarget(methodMeta[index]) === target) {
            throw new Error('Decorator cannot be applied more than once on ' +
                this.getTargetName(target, methodName, parameterIndex));
        }
        // Set the parameter metadata
        methodMeta[index] = this.withTarget(this.inherit(methodMeta[index]), target);
        return localMeta;
    }
    create() {
        return (target, methodName, parameterIndex) => this.decorate(target, methodName, parameterIndex);
    }
    /**
     * Create a parameter decorator function
     * @param key Metadata key
     * @param spec Metadata object from the decorator function
     * @param allowInheritance Inheritance will be honored, default to `true`
     */
    static createDecorator(key, spec, allowInheritance = true) {
        return super._createDecorator(key, spec, allowInheritance);
    }
}
exports.ParameterDecoratorFactory = ParameterDecoratorFactory;
//# sourceMappingURL=decorator-factory.js.map