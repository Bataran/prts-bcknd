"use strict";
// Copyright IBM Corp. 2017. All Rights Reserved.
// Node module: @loopback/repository
// This file is licensed under the MIT License.
// License text available at https://opensource.org/licenses/MIT
var __awaiter = (this && this.__awaiter) || function (thisArg, _arguments, P, generator) {
    return new (P || (P = Promise))(function (resolve, reject) {
        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }
        function rejected(value) { try { step(generator["throw"](value)); } catch (e) { reject(e); } }
        function step(result) { result.done ? resolve(result.value) : new P(function (resolve) { resolve(result.value); }).then(fulfilled, rejected); }
        step((generator = generator.apply(thisArg, _arguments || [])).next());
    });
};
function __export(m) {
    for (var p in m) if (!exports.hasOwnProperty(p)) exports[p] = m[p];
}
Object.defineProperty(exports, "__esModule", { value: true });
exports.jugglerModule = require('loopback-datasource-juggler');
const assert = require("assert");
const context_1 = require("@loopback/context");
__export(require("./loopback-datasource-juggler"));
/* tslint:disable-next-line:variable-name */
exports.DataSourceConstructor = exports.jugglerModule.DataSource;
/* tslint:disable-next-line:variable-name */
exports.ModelBaseConstructor = exports.jugglerModule.ModelBaseClass;
/**
 * This is a bridge to the legacy DAO class. The function mixes DAO methods
 * into a model class and attach it to a given data source
 * @param modelClass {} Model class
 * @param ds {DataSource} Data source
 * @returns {} The new model class with DAO (CRUD) operations
 */
function bindModel(modelClass, ds) {
    const boundModelClass = class extends modelClass {
    };
    boundModelClass.attachTo(ds);
    return boundModelClass;
}
exports.bindModel = bindModel;
/**
 * Ensure the value is a promise
 * @param p Promise or void
 */
/* tslint:disable-next-line:no-any */
function ensurePromise(p) {
    if (p && context_1.isPromise(p)) {
        return p;
    }
    else {
        return Promise.reject(new Error('The value should be a Promise: ' + p));
    }
}
/**
 * Default implementation of CRUD repository using legacy juggler model
 * and data source
 */
class DefaultCrudRepository {
    /**
     * Constructor of DefaultCrudRepository
     * @param modelClass Legacy model class
     * @param dataSource Legacy data source
     */
    constructor(
        // entityClass should have type "typeof T", but that's not supported by TSC
        entityClass, dataSource) {
        this.entityClass = entityClass;
        const definition = entityClass.definition;
        assert(!!definition, `Entity ${entityClass.name} must have valid model definition.`);
        assert(definition.idProperties().length > 0, `Entity ${entityClass.name} must have at least one id/pk property.`);
        // Create an internal legacy Model attached to the datasource
        // We need to convert property definitions from PropertyDefinition
        // to plain data object because of a juggler limitation
        const properties = {};
        for (const p in definition.properties) {
            properties[p] = Object.assign({}, definition.properties[p]);
        }
        this.modelClass = dataSource.createModel(definition.name, properties, definition.settings);
        this.modelClass.attachTo(dataSource);
    }
    create(entity, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = yield ensurePromise(this.modelClass.create(entity, options));
            return this.toEntity(model);
        });
    }
    createAll(entities, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const models = yield ensurePromise(this.modelClass.create(entities, options));
            return this.toEntities(models);
        });
    }
    save(entity, options) {
        const idName = this.modelClass.definition.idName();
        let id;
        if (typeof entity.getId === 'function') {
            id = entity.getId();
        }
        else {
            id = entity[idName];
        }
        if (id == null) {
            return this.create(entity, options);
        }
        else {
            return this.replaceById(id, entity, options).then(result => (result ? this.toEntity(entity) : null));
        }
    }
    find(filter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const models = yield ensurePromise(this.modelClass.find(filter, options));
            return this.toEntities(models);
        });
    }
    findById(id, filter, options) {
        return __awaiter(this, void 0, void 0, function* () {
            const model = yield ensurePromise(this.modelClass.findById(id, filter, options));
            if (!model) {
                return Promise.reject(new Error(`no ${this.modelClass.name} found with id "${id}"`));
            }
            return this.toEntity(model);
        });
    }
    update(entity, options) {
        return this.updateById(entity.getId(), entity, options);
    }
    delete(entity, options) {
        return this.deleteById(entity.getId(), options);
    }
    updateAll(data, where, options) {
        return ensurePromise(this.modelClass.updateAll(where, data, options)).then(result => result.count);
    }
    updateById(id, data, options) {
        const idProp = this.modelClass.definition.idName();
        const where = {};
        where[idProp] = id;
        return this.updateAll(data, where, options).then(count => count > 0);
    }
    replaceById(id, data, options) {
        return ensurePromise(this.modelClass.replaceById(id, data, options)).then(result => !!result);
    }
    deleteAll(where, options) {
        return ensurePromise(this.modelClass.deleteAll(where, options)).then(result => result.count);
    }
    deleteById(id, options) {
        return ensurePromise(this.modelClass.deleteById(id, options)).then(result => result.count > 0);
    }
    count(where, options) {
        return ensurePromise(this.modelClass.count(where, options));
    }
    exists(id, options) {
        return ensurePromise(this.modelClass.exists(id, options));
    }
    toEntity(model) {
        return new this.entityClass(model.toObject());
    }
    toEntities(models) {
        return models.map(m => this.toEntity(m));
    }
}
exports.DefaultCrudRepository = DefaultCrudRepository;
//# sourceMappingURL=legacy-juggler-bridge.js.map